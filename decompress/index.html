<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <script src="main.js"></script>
  <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
    precision highp float;

    in vec4 vertex_position;
    out vec2 float_pos;

    void main() {
      float_pos = vertex_position.xy;
      gl_Position = vertex_position;
    }
  </script>
  <script id="create-lookup-shader" type="x-shader/x-fragment">#version 300 es
    precision highp float;
    precision highp int;
    uniform highp usampler2D compressedData;
    uniform int width;
    uniform int height;
    uniform highp ivec2 cursor;

    in vec2 float_pos;
    out lowp uint val;

    void main() {
      ivec2 pos = ivec2(
        int(0.5 * float(width) * (float_pos.x + 1.0)),
        int(0.5 * float(height) * (float_pos.y + 1.0))
      );

      if (pos.x == 1023 && pos.y == 63) {
        return; // quantile 0x0fff is never used because its right cdf can't be represented in 16 bit.
      }

      uint threshold = uint(pos.x) | (uint(pos.y) << 10);

      highp int endpoint = cursor.x + 200; // 200 is a somewhat arbitrary cutoff here.
      for (highp int x=cursor.x+2; x!=endpoint; ++x) {
        ivec2 readPos = ivec2(x & 1023, cursor.y + (x >> 10));
        uint cdf = texelFetch(compressedData, readPos, 0).r;
        if (cdf > threshold) {
          val = uint(x - (cursor + 2));
          return;
        }
      }
    }
  </script>
  <script id="decode-shader" type="x-shader/x-fragment">#version 300 es
    precision highp float;
    precision highp int;
    uniform highp usampler2D coderHeads;
    uniform highp usampler2D compressedData;
    uniform highp usampler2D lookupTable;
    uniform highp usampler2D coderOffsets1;
    uniform highp usampler2D coderOffsets2;
    uniform highp usampler2D coderOffsets3;
    uniform highp usampler2D coderOffsets4;
    uniform highp usampler2D coderOffsets5;
    uniform int width;
    uniform int height;
    uniform highp ivec2 cursor;

    in vec2 float_pos;
    layout(location=0) out highp uint val;
    layout(location=1) out highp uvec2 newCoderHead;

    void main() {
      ivec2 pos = ivec2(
        int(0.5 * float(width) * (float_pos.x + 1.0)),
        int(0.5 * float(height) * (float_pos.y + 1.0))
      );

      uvec2 head = texelFetch(coderHeads, pos, 0).xy;

      // Refill `head` if necessary:
      if (head.x == 0u) {
        head.x = head.y;
        uint dataOffset = texelFetch(compressedData, cursor, 0).r;
        highp ivec2 readPos = ivec2(pos.x + 1023, pos.y - 1); // subtract 1
        readPos = ivec2(readPos.x & 1023, readPos.y + (readPos.x >> 10)); // realign
        dataOffset += texelFetch(coderOffsets1, readPos, 0).r;
        readPos = ivec2((readPos.x >> 2) + 255, readPos.y - 1);
        readPos = ivec2(readPos.x & 255, readPos.y + (readPos.x >> 8)); // realign
        dataOffset += texelFetch(coderOffsets2, readPos, 0).r;
        highp int readPos_i = ((readPos.y << 5) | (readPos.x >> 3)) - 1;
        dataOffset += texelFetch(coderOffsets3, ivec2(readPos_i & 31, readPos_i >> 5), 0).r;
        readPos_i = (readPos_i >> 5) - 1;
        dataOffset += texelFetch(coderOffsets4, ivec2(0, readPos_i), 0).r;
        readPos_i = (readPos_i >> 5) - 1;
        uvec2 cursor_u = uvec2(uint(cursor.x), uint(cursor.y));
        highp uvec2 offset = texelFetch(coderOffsets5, ivec2(0, readPos_i), 0).xy + cursor_u;
        offset.x += dataOffset;
        offset.y += (offset.x >> 10);
        offset.x = offset.x & 1023u;
        
        head.y = texelFetch(compressedData, ivec2(int(offset.x), int(offset.y)), 0).r;
      }

      // Decode value:
      lowp uint symbol_id = texelFetch(lookupTable, ivec2(int(head.y & 1023u), int(head.y >> 10)), 0).r;
      val = symbol_id;
      highp uint cdf_offset = uint(cursor.x) + symbol_id + 1u;
      highp uint left_cdf = texelFetch(compressedData, ivec2(int(cdf_offset & 1023u), cursor.y + int(cdf_offset >> 10)), 0).r;
      cdf_offset += 1u;
      highp uint right_cdf = texelFetch(compressedData, ivec2(int(cdf_offset & 1023u), cursor.y + int(cdf_offset >> 10)), 0).r;
      highp uint prob = right_cdf - left_cdf;
      highp uint remainder = head.y - left_cdf;

      // We now have to calculate `head.x * prob + remainder`, where each operand is a 16-bit
      // integer and the result is a 32-bit integer. Since WebGL isn't guaranteed to provide 32-bit
      // integer operations, we emulate 32-bit multiplication using 16-bit operations as follows:
      // - We split both 16-bit operands of the multiplication into two 8-bit words:
      //   `head.x = (h1 << 8) | h0` and `prob = (p1 << 8) | p0`.
      // - Thus, `head.x * prob = ((h1 * p1) << 16) | ((h1 * p0 + h0 * p1) << 8) | (h0 * p1)`.
      // - For the entire operation, we obtain, using the notation of long multiplication:
      //       +-------+-------+     +-------+-------+     +-------+-------+
      //       |  h1   |  h0   |  *  |  p1   |  p0   |  +  |   remainder   |  =
      //       +-------+-------+     +-------+-------+     +-------+-------+
      //
      //       +-------+-------+-------+-------+
      //       |   0   |   0   | rem. + h0*p0  |  <-- (need to handle possible overflow)
      //    +  |       |  h0*p1+h1*p0  |   0   |  <-- (need to handle possible overflow)
      //    +  |    h1 * p1    |   0   |   0   |  <-- (can't overflow, not even with carry bit)
      //       +=======+=======+=======+=======+
      //    =  |  ret3 |  ret2 |  ret1 |  ret0 |
      //       +-------+-------+-------+-------+
      //   where the 8-bit words `ret3`, `ret2`, `ret1`, and `ret0` make up the result `ret`.
      // - We sum up each of the four columns in the above block notation, from right to left,
      //   generating carry bits where necessary.

      uint h1 = head.x >> 8;
      uint h0 = head.x & 0xffu;
      uint p1 = prob >> 8;
      uint p0 = prob & 0xffu;

      int ret10_a = int(h0 * p0);
      int ret21_a = int(h0 * p1);
      if (ret10_a > 0xffff - int(remainder)) {
        // `remainder + h0 * p0` overflows 16 bit.
        ret21_a += 0x0100; // Propagate Carry bit to `ret2`. Cannot overflow 16 bit.
        ret10_a -= 0x10000;
      }
      uint ret10 = uint(ret10_a + int(remainder)); // Possible overflow is handled above.
      
      int ret21_b = int(h1 * p0 + (ret10 >> 8)); // Cannot overflow 16 bit.
      uint ret32 = h1 * p1;
      if (ret21_b > 0xffff - ret21_a) {
        // `ret21` overflows 16 bit.
        ret32 += 0x0100u; // Propagate a carry bit into `ret3`.
        ret21_a -= 0x10000;
      }
      uint ret21 = uint(ret21_a + ret21_b); // Possible overflow is handled above.

      uint ret_high16 = ret32 + (ret21 >> 8); // Cannot overflow 16 bit.
      uint ret_low16 = ((ret21 & 0xffu) << 8 ) | (ret10 & 0xffu);
      newCoderHead = uvec2(ret_high16, ret_low16);
    }
  </script>
  <script id="sumOffsets0-shader" type="x-shader/x-fragment">#version 300 es
    precision highp float;
    precision highp int;
    uniform highp usampler2D coderHeads;
    uniform int width;
    uniform int height;

    in vec2 float_pos;
    out lowp uint sum;

    void main() {
      ivec2 pos = ivec2(
        int(0.5 * float(width) * (float_pos.x + 1.0)),
        int(0.5 * float(height) * (float_pos.y + 1.0))
      );

      sum = 0u;
      // TODO: manually unroll this loop and measure performance difference.
      // Also, maybe do comparison to zero in "decode" shader and write result to separate texture.
      for (int i=pos.x & (1023 - 3); i!=pos.x; ++i) {
        sum += uint(texelFetch(coderHeads, ivec2(i, pos.y), 0).x == 0u);
      }
      sum += uint(texelFetch(coderHeads, pos, 0).x == 0u);
    }
  </script>
  <script id="sumOffsets1-shader" type="x-shader/x-fragment">#version 300 es
    precision highp float;
    precision highp int;
    uniform lowp usampler2D coderOffsets1;
    uniform int width;
    uniform int height;

    in vec2 float_pos;
    out lowp uint sum;

    void main() {
      ivec2 pos = ivec2(
        int(0.5 * float(width) * (float_pos.x + 1.0)),
        int(0.5 * float(height) * (float_pos.y + 1.0))
      );

      sum = 0u;
      int endpos = (pos.x << 2) | 3;
      int startpos = endpos & (((255 - 7) * 4) | 3);
      endpos += 4;
      for (int i=startpos; i!=endpos; i+=4) {
        sum += texelFetch(coderOffsets1, ivec2(i, pos.y), 0).r;
      }
    }
  </script>
  <script id="sumOffsets2-shader" type="x-shader/x-fragment">#version 300 es
    precision highp float;
    precision highp int;
    uniform lowp usampler2D coderOffsets2;
    uniform int width;
    uniform int height;

    in vec2 float_pos;
    out highp uint sum;

    void main() {
      ivec2 pos = ivec2(
        int(0.5 * float(width) * (float_pos.x + 1.0)),
        int(0.5 * float(height) * (float_pos.y + 1.0))
      );

      sum = 0u;
      int endpos = ((pos.x + 1) << 3) | 7;
      for (int i=7; i!=endpos; i+=8) {
        sum += texelFetch(coderOffsets2, ivec2(i, pos.y), 0).r;
      }
    }
  </script>
  <script id="sumOffsets3-shader" type="x-shader/x-fragment">#version 300 es
    precision highp float;
    precision highp int;
    uniform highp usampler2D coderOffsets3;
    uniform int width;
    uniform int height;

    in vec2 float_pos;
    out highp uint sum;

    void main() {
      int input_col = 31;
      ivec2 pos = ivec2(
        int(0.5 * float(width) * (float_pos.x + 1.0)),
        int(0.5 * float(height) * (float_pos.y + 1.0))
      );

      sum = 0u;
      int startpos = pos.y & (1023 - 31);
      int endpos = pos.y + 1;
      for (int i=startpos; i!=endpos; ++i) {
        sum += texelFetch(coderOffsets3, ivec2(input_col, i), 0).r;
      }
    }
  </script>
  <script id="sumOffsets4-shader" type="x-shader/x-fragment">#version 300 es
    precision highp float;
    precision highp int;
    uniform highp usampler2D coderOffsets4;
    uniform int width;
    uniform int height;

    in vec2 float_pos;
    out highp uvec2 sum;

    void main() {
      ivec2 pos = ivec2(
        int(0.5 * float(width) * (float_pos.x + 1.0)),
        int(0.5 * float(height) * (float_pos.y + 1.0))
      );

      sum = uvec2(0u, 0u);
      int endpos = ((pos.y + 1) << 5) | 31;
      for (int i=31; i!=endpos; i+=32) {
        sum.x += texelFetch(coderOffsets4, ivec2(0, i), 0).r;
        sum.y += sum.x >> 10;
        sum.x = sum.x & 1023u;
      }
  }
  </script>
  <script>
    window.addEventListener('DOMContentLoaded', run);
  </script>
</head>

<body>
  <canvas id="canvas" width="512" height="256"></canvas>
</body>

</html>
