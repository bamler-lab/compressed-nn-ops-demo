<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <script src="main.js"></script>
  <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
    precision highp float;

    in vec4 vertex_position;
    out vec2 float_pos;

    void main() {
      float_pos = vertex_position.xy;
      gl_Position = vertex_position;
    }
  </script>
  <script id="create-lookup-shader" type="x-shader/x-fragment">#version 300 es
    precision highp float;
    precision mediump int;
    uniform mediump usampler2D compressedMatrix;
    uniform int width;
    uniform int height;

    in vec2 float_pos;
    out lowp uint val;

    void main() {
      uvec2 pos = uvec2(
        uint(0.5 * float(width) * (float_pos.x + 1.0)),
        uint(0.5 * float(height) * (float_pos.y + 1.0))
      );

      int y = 4;
      
      uint threshold = pos.x;
      for (int x=0; x!=200; x+=2) { // 200 is a somewhat arbitrary cutoff here.
        uint cdf = texelFetch(compressedMatrix, ivec2(x, y), 0).r;
        if (cdf > threshold) {
          val = uint(x);
          return;
        }
      }
    }
  </script>
  <script id="compressed-mat-vec-mul-shader" type="x-shader/x-fragment">#version 300 es
    precision highp float;
    precision mediump int;
    uniform mediump usampler2D compressedMatrix;
    uniform lowp usampler2D lookupTable;
    uniform mediump isampler2D vector;
    uniform int width;
    uniform int height;

    in vec2 float_pos;
    out mediump int val;

    void main() {
      uvec2 pos = uvec2(
        uint(0.5 * float(width) * (float_pos.x + 1.0)),
        uint(0.5 * float(height) * (float_pos.y + 1.0))
      );

      uint column = pos.x + 512u * pos.y;
      ivec2 offset_pos = ivec2(int(2u * (column & 255u)), int(column >> 8));
      uint offset_lo = texelFetch(compressedMatrix, offset_pos, 0).r;
      uint offset_hi = texelFetch(compressedMatrix, ivec2(offset_pos.x + 1, offset_pos.y), 0).r;
      uint index = offset_lo | (offset_hi << 16);

      // Initialize decoder
      ivec2 read_pos = ivec2(index & 511u, index >> 9);
      uint head = texelFetch(compressedMatrix, read_pos, 0).r;
      ++index;
      read_pos = ivec2(index & 511u, index >> 9);
      head = (head << 16) | texelFetch(compressedMatrix, read_pos, 0).r;
      
      val = 0;
      ivec2 model_lookup = ivec2(0, 4);

      for (int j=0; j!=2; ++j) {
        for (int i=0; i!=512; ++i) {
          uint quantile = head & uint(0x0fff);
          head = head >> 12;
          model_lookup.x = int(texelFetch(lookupTable, ivec2(quantile & 4095u, 0), 0).r);
          uint left_cdf = texelFetch(compressedMatrix, model_lookup, 0).r;
          ++model_lookup.x;
          uint matrix_entry_uint = texelFetch(compressedMatrix, model_lookup, 0).r;
          int matrix_entry = int(matrix_entry_uint) - int(0x8000);
          ++model_lookup.x;
          uint right_cdf = texelFetch(compressedMatrix, model_lookup, 0).r;
          uint prob =  right_cdf - left_cdf;
          uint remainder = quantile - left_cdf;
          head = head * prob + remainder;

          int vector_entry = texelFetch(vector, ivec2(j, i), 0).r;
          val += matrix_entry * vector_entry;

          if ((head >> 16) == uint(0)) {
            ++index;
            read_pos = ivec2(index & 511u, index >> 9);
            head = (head << 16) | texelFetch(compressedMatrix, read_pos, 0).r;
          }
        }
      }
      val = val % int(256) - 128; // Temporary hack to prevent values from exploding
    }
  </script>
  <script>
    window.addEventListener('DOMContentLoaded', run);
  </script>
</head>

<body>
  <canvas id="canvas" width="512" height="256"></canvas>
</body>

</html>
